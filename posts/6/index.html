<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta charset="utf-8">
    
    
    
    <title>React Hooks系列之useEffect（一） | 狗子赖的博客</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    
    <meta name="theme-color" content="#77AAFF">
    
    
    <meta name="keywords" content="前端">
    
    

    

    <!-- Baidu Push -->
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();

	var _hmt = _hmt || [];
</script>



    
    <meta name="description" content="React Hooks系列之useEffect（一）">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="React Hooks系列之useEffect（一）">
<meta property="og:url" content="http://lry61.cn/posts/6/index.html">
<meta property="og:site_name" content="狗子赖的博客">
<meta property="og:description" content="React Hooks系列之useEffect（一）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5645f/yoda.jpg">
<meta property="og:image" content="https://overreacted.io/counter-46c55d5f1f749462b7a173f1e748e41e.gif">
<meta property="og:image" content="https://overreacted.io/timeout_counter-a5727d333c270e05942f508707265378.gif">
<meta property="og:image" content="https://overreacted.io/timeout_counter_class-264b329edc111a1973003bdf2bcacd65.gif">
<meta property="og:updated_time" content="2019-12-25T05:23:56.927Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React Hooks系列之useEffect（一）">
<meta name="twitter:description" content="React Hooks系列之useEffect（一）">
<meta name="twitter:image" content="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5645f/yoda.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="狗子赖的博客" href="/blog/atom.xml">
    
    <link rel="shortcut icon" href="/blog/img/favicon.ico">
    <link id="style" rel="stylesheet" href="/blog/css/style.css?v=3.0">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
            
</head>

<body>
    <div id="loading" class="active"></div>
    <aside id="menu"  class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" >
      <div class="brand">
        <a href="/blog/" class="avatar waves-effect waves-circle waves-light">
          <img src="/blog/img/avatar.jpg" alt="avatar">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname" id="name">狗子赖</h5>
          
            <div id="yiyanmotto" class="motto">&nbsp;</div>
          
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
              <li class="waves-block waves-effect">
                  <a href="/blog/"  >
                    <i class="icon icon-lg icon-home"></i>
                    <span>主 页</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/blog/archives"  >
                    <i class="icon icon-lg icon-archives"></i>
                    <span>归 档</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/blog/categories"  >
                    <i class="icon icon-lg icon-th-list"></i>
                    <span>分 类</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/blog/tags"  >
                    <i class="icon icon-lg icon-tags"></i>
                    <span>标 签</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/blog/about"  >
                    <i class="icon icon-lg icon-smile-o"></i>
                    <span>关 于</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
      <div class="nav2">
          
              <a class="nav2item" data-title="Email" href="mailto:lry885175073@163.com" target="_parent"title="Email" >
                <i class="icon icon-lg icon-envelope-o envelope-o"></i>
              </a>
          
              <a class="nav2item" data-title="Github" href="https://github.com/Lry0504" target="_blank"title="Github" >
                <i class="icon icon-lg icon-github github"></i>
              </a>
          
              <a class="nav2item" data-title="Twitter" href="https://twitter.com/Larry14624112" target="_blank"title="Twitter" >
                <i class="icon icon-lg icon-twitter twitter"></i>
              </a>
          

            </div>
        
      </ul>
        
    </div>
  </div>
 
</aside>


    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">React Hooks系列之useEffect（一）</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        <a href="../../atom.xml" target="_blank" class="header-icon waves-effect waves-circle waves-light" id="Rss">
            <i class="icon icon-lg icon-rss"></i>
        </a>
    </div>
</header>
<header class="content-header post-header">
    
    
    <div class="container fade-scale">
        <div id="myheader">
            <h1 class="title">
                
            </h1>
            <h5 class="subtitle">
                
                
            </h5>
        </div>
    </div>

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>目录</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#前言"><span class="post-toc-number">1.</span> <span class="post-toc-text">前言</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#摘要"><span class="post-toc-number">2.</span> <span class="post-toc-text">摘要</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#正文"><span class="post-toc-number">3.</span> <span class="post-toc-text">正文</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每一次渲染都有它自己的Props-and-State"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">每一次渲染都有它自己的Props and State</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每一次渲染都有它自己的事件处理函数"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">每一次渲染都有它自己的事件处理函数</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每次渲染都有它自己的Effects"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">每次渲染都有它自己的Effects</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#每一次渲染都有它自己的…"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">每一次渲染都有它自己的…</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#结束语"><span class="post-toc-number">4.</span> <span class="post-toc-text">结束语</span></a></li></ol>
        </nav>
    </aside>
   
<article id="post-react Hooks[2]"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">React Hooks系列之useEffect（一）</h1>
        <div class="post-meta">
            <i class="icon icon-calendar-o"></i>
            发表于
            <time class="post-time" title="2019-12-17 19:47:08" datetime="2019-12-17T11:47:08.984Z"  itemprop="datePublished">2019-12-17</time>

            <br id="mybreak"/>
            
	<i class="icon icon-lg icon-folder-o"></i>
	分类：<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/blog/categories/React/">React</a></li></ul>


            <i>·</i>
            
<span title="文章总阅读量">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>次浏览
</span>


        </div>
        <div class="post-count-custom">
            <i class="icon icon-lg icon-comment-o"></i>
            本文字数总计&nbsp;<span class="post-count">4.7k</span>&nbsp;字,
            阅读本文可能花费您&nbsp;<span class="post-count">18</span>&nbsp;分钟
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>React Hooks系列之useEffect（一）</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你用Hooks写了一些组件，甚或写了一个小型应用。你可能很满意，使用它的API很舒服并且在这个过程中获得了一些小技巧。你甚至可能写了一些<a href="https://reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">custom Hooks</a>去抽离重复的逻辑（精简掉了300行代码），并且得意地展示给你的同事看，“干得漂亮”，他们如是说。</p>
<p>但有时候当你使用useEffect你总觉得哪儿有点不对劲。你会嘀咕你可能遗漏了什么。它看起来像class的生命周期…但真的是这样吗？你发觉自己在问类似下面的这些问题：</p>
<ul>
<li>🤔 如何用useEffect模拟componentDidMount生命周期？</li>
<li>🤔 如何正确地在useEffect里请求数据？[]又是什么？</li>
<li>🤔 我应该把函数当做effect的依赖吗？</li>
<li>🤔 为什么有时候会出现无限重复请求的问题？</li>
<li>🤔 为什么有时候在effect里拿到的是旧的state或prop？</li>
</ul>
<p>当我刚开始使用Hooks的时候，我也同样被上面这些问题所困扰。甚至当我写最初的文档时，我也并没有扎实地掌握某些细节。我经历了一些“啊哈”的开窍时刻，我想把这些分享给你。</p>
<p>在看答案之前，我们需要先往后退一步。这篇文章的目的不是给你一个要点清单，而是想帮你真正地领会useEffect。其实我们并没有太多需要学习的，事实上，我们会花很多时间试图忘记某些已经习得的概念（unlearning）。</p>
<p>当我不再透过熟悉的class生命周期方法去窥视useEffect这个Hook的时候，我才得以融会贯通。</p>
<blockquote>
<p>“忘记你已经学到的。” — Yoda</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://overreacted.io/static/6203a1f1f2c771816a5ba0969baccd12/5645f/yoda.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>如果你对于深入研究感觉不是很适应的话，你或许可以等下面这些解释出现在其他文章中再去了解也行。就像2013年React刚出世的时候，大家需要时间去理解消化一种不同的心智模型。知识也需要时间去普及。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>如果你不想阅读整篇文章，可以快速浏览这份摘要。要是某些部分不容易理解，你可以往下滚动寻找相关的内容去阅读。</p>
<p>🤔 <em>Question</em>: 如何用useEffect模拟componentDidMount生命周期？</p>
<p>虽然可以使用useEffect(fn, [])，但它们并不完全相等。和componentDidMount不一样，useEffect会捕获props和state。所以即便在回调函数里，你拿到的还是初始的props和state。如果你想得到“最新”的值，你可以使用ref。不过，通常会有更简单的实现方式，所以你并不一定要用ref。记住，effects的心智模型和componentDidMount以及其他生命周期是不同的，试图找到它们之间完全一致的表达反而更容易使你混淆。想要更有效，你需要“think in effects”，它的心智模型更接近于实现状态同步，而不是响应生命周期事件。</p>
<p>🤔 <em>Question</em>: 如何正确地在useEffect里请求数据？[]又是什么？</p>
<p><a href="https://www.robinwieruch.de/react-hooks-fetch-data/" target="_blank" rel="noopener">这篇文章</a>是很好的入门，介绍了如何在useEffect里做数据请求。请务必读完它！它没有我的这篇这么长。[] 表示effect没有使用任何React数据流里的值，因此该effect仅被调用一次是安全的。[]同样也是一类常见问题的来源，也即你以为没使用数据流里的值但其实使用了。你需要学习一些策略（主要是useReducer 和 useCallback）来移除这些effect依赖，而不是错误地忽略它们。</p>
<p>🤔 <em>Question</em>: 我应该把函数当做effect的依赖吗？</p>
<p>一般建议把不依赖props和state的函数提到你的组件外面，并且把那些仅被effect使用的函数放到effect里面。如果这样做了以后，你的effect还是需要用到组件内的函数（包括通过props传进来的函数），可以在定义它们的地方用useCallback包一层。为什么要这样做呢？因为这些函数可以访问到props和state，因此它们会参与到数据流中。我们官网的FAQ有<a href="https://reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies" target="_blank" rel="noopener">更详细的答案</a>。</p>
<p>🤔 <em>Question</em>: 为什么有时候会出现无限重复请求的问题？</p>
<p>这个通常发生于你在effect里做数据请求并且没有设置effect依赖参数的情况。没有设置依赖，effect会在每次渲染后执行一次，然后在effect中更新了状态引起渲染并再次触发effect。无限循环的发生也可能是因为你设置的依赖总是会改变。你可以通过一个一个移除的方式排查出哪个依赖导致了问题。但是，移除你使用的依赖（或者盲目地使用[]）通常是一种错误的解决方式。你应该做的是解决问题的根源。举个例子，函数可能会导致这个问题，你可以把它们放到effect里，或者提到组件外面，或者用useCallback包一层。useMemo可以做类似的事情以避免重复生成对象。</p>
<p>🤔 <em>Question</em>: 为什么有时候在effect里拿到的是旧的state或prop呢？</p>
<p><strong>Effect拿到的总是定义它的那次渲染中的props和state</strong>。这能够避免一些bugs，但在一些场景中又会有些讨人嫌。对于这些场景，你可以明确地使用可变的ref保存一些值（上面文章的末尾解释了这一点）。如果你觉得在渲染中拿到了一些旧的props和state，且不是你想要的，你很可能遗漏了一些依赖。可以尝试使用这个<a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener">lint规则</a>来训练你发现这些依赖。可能没过几天，这种能力会变得像是你的第二天性。同样可以看我们官网FAQ中的<a href="https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function" target="_blank" rel="noopener">这个回答</a>。</p>
<p>我希望这个摘要对你有所帮助！要不，我们开始正文。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="每一次渲染都有它自己的Props-and-State"><a href="#每一次渲染都有它自己的Props-and-State" class="headerlink" title="每一次渲染都有它自己的Props and State"></a>每一次渲染都有它自己的Props and State</h3><p>在我们讨论effects之前，我们需要先讨论一下渲染（rendering）。</p>
<p>我们来看一个计数器组件Counter，注意<code>&lt;p&gt;You clicked {count} times&lt;/p&gt;</code>这一行：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Counter() {</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>注意的代码究竟是什么意思呢？count 会“监听”状态的变化并自动更新吗？这么想可能是学习React的时候有用的第一直觉，但它并不是<a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">精确的心智模型</a>。</p>
<p>上面例子中，count仅是一个数字而已。它不是神奇的“data binding”, “watcher”, “proxy”，或者其他任何东西。它就是一个普通的数字像下面这个一样：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const count = 42;</span><br><span class="line">// ...</span><br><span class="line">&lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">// ...</span><br></pre></td></tr></tbody></table></figure>

<p>我们的组件第一次渲染的时候，从useState()拿到count的初始值0。当我们调用setCount(1)，React会再次渲染组件，这一次count是1。如此等等：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// During first render</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 0; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After a click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 1; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After another click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 2; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">  // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>当我们更新状态的时候，React会重新渲染组件。每一次渲染都能拿到独立的count 状态，这个状态值是函数中的一个常量。</strong></p>
<p>所以下面的这行代码没有做任何特殊的数据绑定：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>它仅仅只是在渲染输出中插入了count这个数字。这个数字由React提供。当setCount的时候，React会带着一个不同的count值再次调用组件。然后，React会更新DOM以保持和渲染输出一致。</p>
<p>这里关键的点在于任意一次渲染中的count常量都不会随着时间改变。渲染输出会变是因为我们的组件被一次次调用，而每一次调用引起的渲染中，它包含的count值独立于其他渲染。</p>
<p>（关于这个过程更深入的探讨可以查看我的另一篇文章<a href="https://overreacted.io/react-as-a-ui-runtime/" target="_blank" rel="noopener">React as a UI Runtime</a>）</p>
<h3 id="每一次渲染都有它自己的事件处理函数"><a href="#每一次渲染都有它自己的事件处理函数" class="headerlink" title="每一次渲染都有它自己的事件处理函数"></a>每一次渲染都有它自己的事件处理函数</h3><p>到目前为止一切都还好。那么事件处理函数呢？</p>
<p>看下面的这个例子。它在三秒后会alert点击次数count：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function Counter() {</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + count);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;button onClick={handleAlertClick}&gt;</span><br><span class="line">        Show alert</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我按照下面的步骤去操作：</p>
<ul>
<li>点击增加count到3</li>
<li>点击一下 “Show alert”</li>
<li>点击增加count到5并且在定时器回调触发前完成<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://overreacted.io/counter-46c55d5f1f749462b7a173f1e748e41e.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
你猜alert会弹出什么呢？会是5吗？— 这个值是alert的时候count的实时状态。或者会是3吗？— 这个值是我点击时候的状态。</li>
</ul>
<p>来自己<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">试试吧！</a></p>
<p>如果结果和你预料不一样，你可以想象一个更实际的例子：一个聊天应用在state中保存了当前接收者的ID，以及一个发送按钮。<a href="https://overreacted.io/how-are-function-components-different-from-classes/" target="_blank" rel="noopener">这篇文章</a>深入探索了个中缘由。正确的答案就是3。</p>
<p>alert会“捕获”我点击按钮时候的状态。</p>
<p>（虽然有其他办法可以实现不同的行为，但现在我会专注于这个默认的场景。当我们在构建一种心智模型的时候，在可选的策略中分辨出“最小阻力路径”是非常重要的。）</p>
<p>但它究竟是如何工作的呢？</p>
<p>我们发现count在每一次函数调用中都是一个常量值。值得强调的是 — <em>我们的组件函数每次渲染都会被调用，但是每一次调用中count值都是常量，并且它被赋予了当前渲染中的状态值。</em></p>
<p>这并不是React特有的，普通的函数也有类似的行为：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function sayHi(person) {</span><br><span class="line">  const name = person.name;</span><br><span class="line">  setTimeout(() =&gt; {</span><br><span class="line">    alert('Hello, ' + name);</span><br><span class="line">  }, 3000);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">let someone = {name: 'Dan'};</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = {name: 'Yuzhi'};</span><br><span class="line">sayHi(someone);</span><br><span class="line"></span><br><span class="line">someone = {name: 'Dominic'};</span><br><span class="line">sayHi(someone);</span><br></pre></td></tr></tbody></table></figure>

<p>在<a href="https://codesandbox.io/s/mm6ww11lk8" target="_blank" rel="noopener">这个例子</a>中, 外层的someone会被赋值很多次（就像在React中，当前的组件状态会改变一样）。然后，在sayHi函数中，局部常量name会和某次调用中的person关联。因为这个常量是局部的，所以每一次调用都是相互独立的。结果就是，当定时器回调触发的时候，每一个alert都会弹出它拥有的name。</p>
<p>这就解释了我们的事件处理函数如何捕获了点击时候的count值。如果我们应用相同的替换原理，每一次渲染“看到”的是它自己的count：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// During first render</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 0; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + count);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After a click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 1; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + count);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After another click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  const count = 2; // Returned by useState()</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + count);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以实际上，每一次渲染都有一个“新版本”的handleAlertClick。每一个版本的handleAlertClick“记住” 了它自己的 count：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// During first render</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + 0);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">  &lt;button onClick={handleAlertClick} /&gt; // The one with 0 inside</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After a click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + 1);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">  &lt;button onClick={handleAlertClick} /&gt; // The one with 1 inside</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After another click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  function handleAlertClick() {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      alert('You clicked on: ' + 2);</span><br><span class="line">    }, 3000);</span><br><span class="line">  }</span><br><span class="line">  // ...</span><br><span class="line">  &lt;button onClick={handleAlertClick} /&gt; // The one with 2 inside</span><br><span class="line">  // ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这就是为什么在<a href="https://codesandbox.io/s/w2wxl3yo0l" target="_blank" rel="noopener">这个demo中</a>，事件处理函数“属于”某一次特定的渲染，当你点击的时候，它会使用那次渲染中count的状态值。</p>
<p><strong>在任意一次渲染中，props和state是始终保持不变的。</strong>如果props和state在不同的渲染中是相互独立的，那么使用到它们的任何值也是独立的（包括事件处理函数）。它们都“属于”一次特定的渲染。即便是事件处理中的异步函数调用“看到”的也是这次渲染中的count值。</p>
<p>备注：上面我将具体的count值直接内联到了handleAlertClick函数中。这种心智上的替换是安全的，因为count值在某次特定渲染中不可能被改变。它被声明成了一个常量并且是一个数字。这样去思考其他类型的值比如对象也同样是安全的，当然需要在我们都同意应该避免直接修改state这个前提下。通过调用setSomething(newObj)的方式去生成一个新的对象而不是直接修改它是更好的选择，因为这样能保证之前渲染中的state不会被污染。</p>
<h3 id="每次渲染都有它自己的Effects"><a href="#每次渲染都有它自己的Effects" class="headerlink" title="每次渲染都有它自己的Effects"></a>每次渲染都有它自己的Effects</h3><p>这篇文章是关于effects的，但目前我们居然还没有讨论effects！ 言归正传，由上面的分析得出一个结果，effects其实并没有什么两样。</p>
<p>让我们回到<a href="https://reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener">官网文档</a>中的这个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Counter() {</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; {</span><br><span class="line">    document.title = `You clicked ${count} times`;</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>抛一个问题给你：effect是如何读取到最新的count 状态值的呢？</p>
<p>也许，是某种“data binding”或“watching”机制使得count能够在effect函数内更新？也或许count是一个可变的值，React会在我们组件内部修改它以使我们的effect函数总能拿到最新的值？</p>
<p>都不是。</p>
<p>我们已经知道count是某个特定渲染中的常量。事件处理函数“看到”的是属于它那次特定渲染中的count状态值。对于effects也同样如此：</p>
<p>并不是count的值在“不变”的effect中发生了改变，而是effect函数本身在每一次渲染中都不相同。</p>
<p>每一个effect版本“看到”的count值都来自于它属于的那次渲染：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// During first render</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  useEffect(</span><br><span class="line">    // Effect function from first render</span><br><span class="line">    () =&gt; {</span><br><span class="line">      document.title = `You clicked ${0} times`;</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After a click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  useEffect(</span><br><span class="line">    // Effect function from second render</span><br><span class="line">    () =&gt; {</span><br><span class="line">      document.title = `You clicked ${1} times`;</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">  // ...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">// After another click, our function is called again</span><br><span class="line">function Counter() {</span><br><span class="line">  // ...</span><br><span class="line">  useEffect(</span><br><span class="line">    // Effect function from third render</span><br><span class="line">    () =&gt; {</span><br><span class="line">      document.title = `You clicked ${2} times`;</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">  // ..</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>React会记住你提供的effect函数，并且会在每次更改作用于DOM并让浏览器绘制屏幕后去调用它。</p>
<p>所以虽然我们说的是一个effect（这里指更新document的title），但其实每次渲染都是一个不同的函数 — 并且每个effect函数“看到”的props和state都来自于它属于的那次特定渲染。</p>
<p>概念上，你可以想象effects是渲染结果的一部分。</p>
<p>严格地说，它们并不是（为了<a href="https://overreacted.io/why-do-hooks-rely-on-call-order/" target="_blank" rel="noopener">允许Hook的组合</a>并且不引入笨拙的语法或者运行时）。但是在我们构建的心智模型上，effect函数属于某个特定的渲染，就像事件处理函数一样。</p>
<p>为了确保我们已经有了扎实的理解，我们再回顾一下第一次的渲染过程：</p>
<ul>
<li>React: 给我状态为0时候的UI。</li>
<li>你的组件:<ul>
<li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 0 times&lt;/p&gt;</code>。</li>
<li>记得在渲染完了之后调用这个effect: () =&gt; { document.title = ‘You clicked 0 times’ }。</li>
</ul>
</li>
<li>React: 没问题。开始更新UI，喂浏览器，我要给DOM添加一些东西。</li>
<li>浏览器: 酷，我已经把它绘制到屏幕上了。</li>
<li>React: 好的， 我现在开始运行给我的effect<ul>
<li>运行 () =&gt; { document.title = ‘You clicked 0 times’ }。</li>
</ul>
</li>
</ul>
<p>现在我们回顾一下我们点击之后发生了什么：</p>
<ul>
<li>你的组件: 喂 React, 把我的状态设置为1。</li>
<li>React: 给我状态为1时候的UI。</li>
<li>你的组件:<ul>
<li>给你需要渲染的内容: <code>&lt;p&gt;You clicked 1 times&lt;/p&gt;</code>。</li>
<li>记得在渲染完了之后调用这个effect： () =&gt; { document.title = ‘You clicked 1 times’ }。</li>
</ul>
</li>
<li>React: 没问题。开始更新UI，喂浏览器，我修改了DOM。</li>
<li>Browser: 酷，我已经将更改绘制到屏幕上了。</li>
<li>React: 好的， 我现在开始运行属于这次渲染的effect<ul>
<li>运行 () =&gt; { document.title = ‘You clicked 1 times’ }。</li>
</ul>
</li>
</ul>
<h3 id="每一次渲染都有它自己的…"><a href="#每一次渲染都有它自己的…" class="headerlink" title="每一次渲染都有它自己的…"></a>每一次渲染都有它自己的…</h3><p>我们现在知道effects会在每次渲染后运行，并且概念上它是组件输出的一部分，可以“看到”属于某次特定渲染的props和state。</p>
<p>我们来做一个思想实验，思考下面的代码：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Counter() {</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line"></span><br><span class="line">  useEffect(() =&gt; {</span><br><span class="line">    setTimeout(() =&gt; {</span><br><span class="line">      console.log(`You clicked ${count} times`);</span><br><span class="line">    }, 3000);</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked {count} times&lt;/p&gt;</span><br><span class="line">      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我点击了很多次并且在effect里设置了延时，打印出来的结果会是什么呢？</p>
<p>你可能会认为这是一个很绕的题并且结果是反直觉的。完全错了！我们看到的就是顺序的打印输出 — 每一个都属于某次特定的渲染，因此有它该有的count值。你可以<a href="https://codesandbox.io/s/lyx20m1ol" target="_blank" rel="noopener">自己试一试</a>：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://overreacted.io/timeout_counter-a5727d333c270e05942f508707265378.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>你可能会想：“它当然应该是这样的。否则还会怎么样呢？”</p>
<p>不过，class中的this.state并不是这样运作的。你可能会想当然以为下面的<a href="https://codesandbox.io/s/kkymzwjqz3" target="_blank" rel="noopener">class实现</a>和上面是相等的：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate() {</span><br><span class="line">  setTimeout(() =&gt; {</span><br><span class="line">    console.log(`You clicked ${this.state.count} times`);</span><br><span class="line">  }, 3000);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然而，<strong>this.state.count总是指向最新的count值，而不是属于某次特定渲染的值</strong>。所以你会看到每次打印输出都是5：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://overreacted.io/timeout_counter_class-264b329edc111a1973003bdf2bcacd65.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>我觉得Hooks这么依赖Javascript闭包是挺讽刺的一件事。有时候组件的class实现方式会受闭包相关的苦（<a href="https://wsvincent.com/javascript-closure-settimeout-for-loop/" target="_blank" rel="noopener">the canonical wrong-value-in-a-timeout confusion</a>），但其实这个例子中真正的混乱来源是可变数据（React修改了class中的this.state使其指向最新状态），并不是闭包本身的错。</p>
<p>当封闭的值始终不会变的情况下闭包是非常棒的。这使它们非常容易思考因为你本质上在引用常量。正如我们所讨论的，props和state在某个特定渲染中是不会改变的。顺便说一下，我们可以<a href="https://codesandbox.io/s/w7vjo07055" target="_blank" rel="noopener">使用闭包</a>修复上面的class版本…</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote>
<p>原文作者：Dan Abramov<br>原文链接：<a href="https://overreacted.io/a-complete-guide-to-useeffect/" target="_blank" rel="noopener">https://overreacted.io/a-complete-guide-to-useeffect/</a></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
        </div>
        <div>
  <div>
      <!-- {% if not is_index %} -->
      <div style="text-align:center;color: #ccc;font-size:14px;margin-bottom: 10px;">-----------------------<span style="margin: 0 10px;">本文结束</span><i class="icon icon-paw"></i><span style="margin: 0 10px;">感谢您的阅读</span>-----------------------</div>
      <!-- {% endif %} -->
  </div>
</div>
        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新：<time datetime="2019-12-25T05:23:56.927Z" itemprop="dateUpdated">2019-12-25 13:23:56</time>
</span>


        
        原文链接：<a href="/blog/posts/6/" target="_blank" rel="external">http://lry61.cn/posts/6/</a>
        
    </div>
    <footer>
        <div onclick="location.href='http://lry61.cn'">
            <img src="/blog/img/avatar.jpg" alt="狗子赖">
            <a>狗子赖</a>
        </div>
    </footer>
</blockquote>

        
    <div class="page-reward">
        <nav class="myreward">
            <a id="rewardBtn" href="javascript:;"><span>打&nbsp;赏</span><span>装成好像很多人打赏的样子</span></a>
        </nav>
    </div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/前端/">前端</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lry61.cn/posts/6/&title=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&pic=http://lry61.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lry61.cn/posts/6/&title=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&source=React Hooks系列之useEffect（一）" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lry61.cn/posts/6/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&url=http://lry61.cn/posts/6/&via=http://lry61.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lry61.cn/posts/6/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/blog/posts/7/" id="post-prev" class="post-nav-link">
        <h4 class="title" >
          上一篇：React Hooks系列之useEffect（二）
        </h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/blog/posts/5/" id="post-next" class="post-nav-link">
        <h4 class="title" data-hover="下一篇：React Hooks初探">下一篇：React Hooks初探</h4>
      </a>
    </div>
  
</nav>



    
    

    

    
    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['昵称','邮箱','网址'];
        var guest_info = '昵称,邮箱,网址'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "wQrz3akctyLkzYGySxn1FgY8-gzGzoHsz",
            appKey: "hYgkRpoK57mCsRlCFtp7Qor2",
            avatar: "mm",
            placeholder: "欢迎留言~",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->



</article>

</div>

        <footer class="footer">
    <div class="footer-content">
        <span class="power">
            <i class="icon icon-lg icon-copyright"></i>
            2019
            <i class="icon icon-lg icon-heart"></i>
            <a href="http://lry61.cn">https://github.com/Lry0504</a>
        </span>

        <br/>

        <span id="RunTime" style="color:#a7a7a2;"></span>
        <br/>

        <span>
            
	<i class="icon icon-lg icon-user">
    <span>
      访客人数：
      <span id="busuanzi_value_site_uv"></span>
    </span>人
  </i>
    ·
  <i class="icon icon-lg icon-eye">
    <span>
      总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>次
  </i>


        </span>
        <!-- <br/> -->

        <!-- <span class="license"><a  target="_blank" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span> -->
    </div>
</footer>

    </main>
    
        
<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        <span>感谢您的鼓励支持！</span>
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" data-img="/blog/img/dog.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/blog/img/wechat.png" data-alipay="/blog/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechatPay">&nbsp;&nbsp;微信&nbsp;&nbsp;</span>
                <span class="reward-toggle-item alipayPay">支付宝</span>
            </div>
        </label>
        
        <i class="icon icon-caret-up"></i>
    </div>
</div>


    
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://lry61.cn/posts/6/&title=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&pic=http://lry61.cn/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://lry61.cn/posts/6/&title=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&source=React Hooks系列之useEffect（一）" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://lry61.cn/posts/6/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《React Hooks系列之useEffect（一）》 — 狗子赖的博客&url=http://lry61.cn/posts/6/&via=http://lry61.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://lry61.cn/posts/6/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p class="wechatshare">扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAACWCAAAAAAZai4+AAABUklEQVR42u3aQRLEIAhEUe9/aecAKU03kMXAZzWVqonPRUTBteTYj3g+vz9ZXwQsWI1Y+xrKYKeB7+85jQUL1mTW6aWn38pCoC8WsGDBirHcnAsLFqxa1j3pxqYECxYsfdPsTkZJ8wV7eViwWrAy6TazKJTVt2DB+nPWNiNDN0aBBWsYS/+A3ZJubEqwYM1kxdqWbhPFLgrDgjWMlTmaKv9SUv5xwrBgjWFlmpf6G9yiFSxYM1mZiz73z14hSoUkWLBas/LtEPdAaxR/YcEayTJ22WZq1wtSbyUvWLD6s/SBY6UiZRRYsGBVLQf69YKXzTcsWGNYsasA+kE3VmCCBWsaK38vLnNpryBgwWrEqioSxZou0qYZFqwxLPcjD7ZM5AITLFiw8otCQdqGBQuWvEDojRn30AsL1kyWsmnOtGGMJA0L1khWQX9GTvDFAQtWB9YPzk01/aGkRoUAAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <!-- waves按钮特效 -->
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<!-- 主题配置脚本 -->
<script>
var BLOG = { ROOT: '/blog/', SHARE: true, REWARD: true };
</script>

<!-- jquery -->
<script src="/blog/js/jquery.min.js?v=3.0"></script>

<!-- 搜索 -->

<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item waves-block waves-effect" onclick="location.href='{path}'">
    <div class="title ellipsis" title="{title}">{title}</div>
</li>
</template>


<!-- main博客脚本 -->
<script src="/blog/js/main.min.js?v=3.0" ></script>

<!-- 动画&配置 -->
<script src="/blog/js/script.min.js?v=3.0" ></script>

<!-- 脚本管理 -->
<script>

if(window.innerWidth > 800){
	/* 3D标题 */
	$(".content-header").on("mousemove", threedee);

	/* 底部追随鼠标 */
	$(".footer").hover(2);

	/* gotop键的涟漪 */
	$("#gotop").hover(1);

	/* 赞赏的粒子雨 */
	$("#reward").hover(3);

	/* 微信公众号的底部渲染 */
	$("#wechat").hover(4);

    /* 标题跳动 */
    $(".archivestitle").bumpyText();

	/* 图片点击放大 */
	const postimg = jQuery(".post-content img:not(.github-emoji)");
	postimg.on("click",function(){

		mask.classList.add("in");
		main.classList.add("Mask");
		menu.classList.add("Mask");
		var myimg = this.cloneNode(true);
		myimg.classList.add("imgShow");

		setTimeout(function(){
			jQuery(myimg).animate({
				opacity:"1"
			},1000);
		},0);

		document.body.appendChild(myimg);

		myimg.onclick=function(){
			document.body.removeChild(myimg);
			mask.classList.remove("in");
			main.classList.remove("Mask");
			menu.classList.remove("Mask");
		};

	});

}

/* 名字跳动 */
$("#name").bumpyText();


/* 网站运行时间 */
setInterval(function () {
	setTime("2019/08/21");
}, 1000);

/* 文章块的淡出 */
postshow();

/* 座右铭 */

   getHitokoto();



/* 粘贴提示 */
G($(".post-content"), location.href, "狗子赖");


/* 控制台 */
if (window.console && window.console.log) {
	setTimeout(function () {
		console.log("\n %c 天妒嘤才狗子赖 %c  © Lry0504  http://Lry0504.github.io \n\n", "color:#FFFFFB;background:#1abc9c;padding:5px 0;border-radius:.5rem 0 0 .5rem;", "color:#FFFFFB;background:#080808;padding:5px 0;border-radius:0 .5rem .5rem 0;");
	}, 0);
}

</script>




<!-- 公式渲染 -->



<!-- 不蒜子 -->

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!-- Online contact -->


<!-- 代码块复制功能 -->
<script src ="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
!function (e, t, a) {
  var initCopyCode = function(){
    var copyHtml = '';
    copyHtml += '<button class="btn-copy" data-clipboard-snippet="copy">';
    copyHtml += '<span>Copy</span>';
    copyHtml += '</button>';
    $(".highlight .code pre").before(copyHtml);
    new ClipboardJS('.btn-copy', {
      target: function(trigger) {
        return trigger.nextElementSibling;
      }
    });
  }
  initCopyCode();
}(window, document);
</script>

<script src="/blog/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/blog/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.7}});</script></body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>狗子赖的博客</title>
  
  <subtitle>你装作不懂，我也故作轻松</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://Lry0504.github.io/"/>
  <updated>2019-08-22T08:30:47.297Z</updated>
  <id>http://Lry0504.github.io/</id>
  
  <author>
    <name>狗子赖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欢迎来到狗子赖的博客</title>
    <link href="http://Lry0504.github.io//posts/fbf759eb/"/>
    <id>http://Lry0504.github.io//posts/fbf759eb/</id>
    <published>2019-08-22T07:14:46.311Z</published>
    <updated>2019-08-22T08:30:47.297Z</updated>
    
    <content type="html"><![CDATA[<p>this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象</p><a id="more"></a><p> <strong><em>（1）、作为函数名调用</em></strong><br>  函数作为全局对象调用，this指向全局对象</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> author = <span class="string">"lry"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.author); <span class="comment">//undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//Window</span></span><br><span class="line">}</span><br><span class="line">a(); <span class="comment">//其实这是相当于 window.a()</span></span><br></pre></td></tr></tbody></table></figure><p><strong><em>（2）、作为方法调用</em></strong><br>  函数作为对象中的一个属性，成为该对象的一个方法，this指向该对象</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    author:<span class="string">"lry"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.author);  <span class="comment">//lry</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">o.fn(); <span class="comment">//this =&gt; o</span></span><br></pre></td></tr></tbody></table></figure><p><strong><em>（3）、使用构造函数调用</em></strong><br>  使用new调用的函数，则其中this将会被绑定到那个新构造的对象。（首先new关键字会创建一个空的对象，然后会自动调用一个函数方法(apply…)，将this指向这个空对象，这样的话函数内部的this就会被这个空的对象替代）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>) </span>{</span><br><span class="line"><span class="keyword">this</span>.author = <span class="string">"lry"</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(o.author); <span class="comment">//lry</span></span><br></pre></td></tr></tbody></table></figure><p><strong><em>（4）、apply或call调用</em></strong><br>  自行改变this指向，函数this指向apply或call方法调用时的第一个参数</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    author:<span class="string">"lry"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.author); <span class="comment">//lry</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> b = o.fn;</span><br><span class="line">b.call(o); <span class="comment">//或者 b.apply(o)</span></span><br></pre></td></tr></tbody></table></figure><p><strong><em>补充：</em></strong><br>  this的最终指向的是那个调用它的对象（大多数可以这么理解，但并不是准确的）</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:{</span><br><span class="line">        a:<span class="number">20</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//20</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></tbody></table></figure><p>这里的this为什么不是指向o？如果按照上面的理论，最终this指向的是调用它的对象，因为 <strong>如果一个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象</strong>。看下面例子：虽然对象b中没有属性a，但this仍然指向的是它的上一级对象b</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:{</span><br><span class="line">        <span class="comment">//a:20,</span></span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//undefined</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">o.b.fn();</span><br></pre></td></tr></tbody></table></figure><p><strong><em>特殊情况：</em></strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = {</span><br><span class="line">    a:<span class="number">10</span>,</span><br><span class="line">    b:{</span><br><span class="line">        a:<span class="number">20</span>,</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//window</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> c = o.b.fn;</span><br><span class="line">c();</span><br></pre></td></tr></tbody></table></figure><p>这是的this指向的是window…为什么呢？如果你还没缓过神来的话，那你可能没有理解<strong>this指向的永远是最后调用它的对象。</strong></p><blockquote><p>如有错误，欢迎指正<del>~</del></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="life" scheme="http://Lry0504.github.io/tags/life/"/>
    
  </entry>
  
</feed>
